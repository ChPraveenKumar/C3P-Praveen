package com.techm.orion.rest;

import java.awt.Font;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.annotation.Annotation;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.Properties;
import java.util.TreeMap;

import javax.persistence.Column;
import javax.servlet.http.HttpServletResponse;
import javax.validation.constraints.Null;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;
import javax.ws.rs.core.StreamingOutput;

import org.apache.commons.io.IOUtils;
import org.apache.commons.validator.routines.InetAddressValidator;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.BorderStyle;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.ConditionalFormattingRule;
import org.apache.poi.ss.usermodel.FillPatternType;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.SheetConditionalFormatting;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.glassfish.jersey.media.multipart.FormDataMultiPart;
import org.glassfish.jersey.media.multipart.MultiPart;
import org.glassfish.jersey.media.multipart.file.FileDataBodyPart;
import org.hibernate.mapping.Set;
import org.json.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.Query;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import org.apache.poi.ss.usermodel.Cell;

import javax.ws.rs.core.MediaType;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.mysql.jdbc.Field;
import com.techm.orion.dao.RequestInfoDao;
import com.techm.orion.dao.TemplateSuggestionDao;
import com.techm.orion.entitybeans.DeviceInterfaceEntity;
import com.techm.orion.entitybeans.EIPAMEntity;
import com.techm.orion.entitybeans.InternetInfoEntity;
import com.techm.orion.entitybeans.RequestDetailsEntity;
import com.techm.orion.entitybeans.RouterVfEntity;
import com.techm.orion.entitybeans.Vendors;
import com.techm.orion.entitybeans.WebServiceEntity;
import com.techm.orion.exception.InvalidValueException;
import com.techm.orion.pojo.CreateConfigRequest;
import com.techm.orion.pojo.CreateConfigRequestDCM;
import com.techm.orion.pojo.TemplateBasicConfigurationPojo;
import com.techm.orion.repositories.DeviceInterfaceRepo;
import com.techm.orion.repositories.DeviceTypeRepository;
import com.techm.orion.repositories.InternetInfoRepo;
import com.techm.orion.repositories.ModelsRepository;
import com.techm.orion.repositories.OSRepository;
import com.techm.orion.repositories.OSversionRepository;
import com.techm.orion.repositories.RequestDetailsExportRepo;
import com.techm.orion.repositories.RouterVfRepo;
import com.techm.orion.repositories.VendorRepository;
import com.techm.orion.repositories.WebServiceRepo;
import com.techm.orion.service.CSVWriteAndConnectPythonTemplateSuggestion;
import com.techm.orion.service.DcmConfigService;

import org.apache.commons.validator.routines.InetAddressValidator;

@RestController
@RequestMapping("/DataValidationImport")
@CrossOrigin(origins = "http://localhost:4200", maxAge = 3600)
public class DataValidationImport implements Observer {

	// private static final String FILE_PATH = null;

	// private static final String STYLE_CELL_BORDERED = null;

	public static String TSA_PROPERTIES_FILE = "TSA.properties";

	public static final Properties TSA_PROPERTIES = new Properties();
	DcmConfigService dcmConfigService = new DcmConfigService();
	JSONObject jsonObj;
	JSONArray array = new JSONArray();
	TemplateSuggestionDao templateSuggestionDao = new TemplateSuggestionDao();
	@Autowired
	RequestDetailsExportRepo requestDetailsExportRepo;

	@Autowired
	DeviceInterfaceRepo deviceInterfaceRepo;

	@Autowired
	InternetInfoRepo internetInfoRepo;

	@Autowired
	RouterVfRepo routerVfRepo;

	@Autowired
	WebServiceRepo webServiceRepo;

	@Autowired
	VendorRepository vendorRepository;

	@Autowired
	DeviceTypeRepository deviceTypeRepository;

	@Autowired
	ModelsRepository modelsRepository;

	@Autowired
	OSRepository oSRepository;

	@Autowired
	OSversionRepository oSversionRepository;

	RequestInfoDao requestInfoDao = new RequestInfoDao();
	CreateConfigRequest createConfigRequest = new CreateConfigRequest();

	@GET
	@Produces("application/json")
	@RequestMapping(value = "/importvalid", method = RequestMethod.GET, produces = "application/json")
	public Response validateImport(@RequestParam int request_info_id)
			throws IOException {

		RequestDetailsEntity entity = new RequestDetailsEntity();
		DeviceInterfaceEntity ExportList2 = new DeviceInterfaceEntity();
		InternetInfoEntity ExportList3 = new InternetInfoEntity();
		Gson gson = new Gson();

		JSONObject obj = new JSONObject();
		String jsonMessage = "";
		String jsonArray = "";
		String jsonArray1 = "";
		RequestDetailsEntity ExportList = new RequestDetailsEntity();

		RequestDetailsExport.loadProperties();

		JSONObject names = new JSONObject();
		JSONObject values = new JSONObject();
		try {

			List<String> vendorlist = vendorRepository.findVendors();
			List<String> devicelist = deviceTypeRepository.findDevice();
			List<String> modellist = modelsRepository.findModel();
			List<String> oslist = oSRepository.findOs();
			List<String> osVersionlist = oSversionRepository.findOsVersion();

			ExportList = requestDetailsExportRepo
					.findByrequestinfoid(request_info_id);

			String Device = ExportList.getDevice_type();
			String vendor = ExportList.getVendor();
			String model = ExportList.getModel();
			String os = ExportList.getOs();
			String osversion = ExportList.getOs_version();

			// ArrayList<String> names = new ArrayList<String>();

			int request_id = ExportList.getRequestinfoid();

			String request = Integer.toString(request_id);

			String Vendor = ExportList.getVendor();
			// boolean flag1 = true;
			boolean flag1 = false;
			for (String string : vendorlist) {

				if (string.equals(Vendor)) {
					// allMatch = true;

					flag1 = true;
					System.out.println("Matched VENDOR");
				}

			}
			if (flag1 == true) {
				names.put("Vendor", 1);
				values.put("Vendor_Name", vendor);
			} else {
				names.put("Vendor", 0);
				values.put("Vendor_Name", vendor);
			}
			boolean flag2 = false;
			String DeviceType = ExportList.getDevice_type();
			for (String string : devicelist) {
				if (string.equals(DeviceType)) {

					flag2 = true;
					System.out.println("Matched device");

				}

			}
			if (flag2 == true) {
				names.put("Device", 1);
				values.put("Device_Name", Device);
			} else {
				names.put("Device", 0);
				values.put("Device_Name", Device);
			}
			boolean flag3 = false;
			String Model = ExportList.getModel();
			for (String string : modellist) {
				if (string.equals(Model)) {

					flag3 = true;
					System.out.println("Matched model");
				}

			}
			if (flag3 == true) {
				names.put("Model", 1);
				values.put("Model_Name", model);
			} else {
				names.put("Model", 0);
				values.put("Model_Name", model);
			}
			boolean flag4 = false;
			String Os = ExportList.getOs();
			for (String string : oslist) {
				if (string.equals(Os)) {

					flag4 = true;
					System.out.println("Matched os");
				}

			}
			if (flag4 == true) {
				names.put("os", 1);
				values.put("os_Name", os);
			}

			else {
				names.put("os", 0);
				values.put("os_Name", os);
			}
			boolean flag5 = false;
			String OsVersion = ExportList.getOs_version();
			for (String string : osVersionlist) {
				if (string.equals(OsVersion)) {

					flag5 = true;
					System.out.println("Matched os version");
				}

			}
			if (flag5 == true) {
				names.put("OS_Version", 1);
				values.put("os_Version_Name", osversion);
			} else {
				names.put("OS_Version", 0);
				values.put("os_Version_Name", osversion);
			}

			List<String> Validationlist = new ArrayList<String>();

			String MessageReport = "";
			names.put("Request Id", request_id);
			int Datavalid;
			if (flag1 == true && flag2 == true && flag3 == true
					&& flag4 == true && flag5 == true) {
				Datavalid = 1;

			} else {
				Datavalid = 0;
				MessageReport = "Device Support Validation Failed";
				ExportList.setRequeststatus(MessageReport);

			}
			requestDetailsExportRepo.save(ExportList);
			// List<EIPAMEntity> detailsList = new ArrayList<EIPAMEntity>();
			jsonArray = new Gson().toJson(names);
			jsonArray1 = new Gson().toJson(values);
			obj.put(new String("Values"), jsonArray1);
			obj.put(new String("output"), jsonArray);
			obj.put(new String("Datavalid"), Datavalid);
		} catch (Exception e) {
			System.out.println(e);
		}

		return Response
				.status(200)
				.header("Access-Control-Allow-Origin", "*")
				.header("Access-Control-Allow-Headers",
						"origin, content-type, accept, authorization")
				.header("Access-Control-Allow-Credentials", "true")
				.header("Access-Control-Allow-Methods",
						"GET, POST, PUT, DELETE, OPTIONS, HEAD")
				.header("Access-Control-Max-Age", "1209600").entity(obj)
				.build();
	}

	@Override
	public void update(Observable o, Object arg) {
		// TODO Auto-generated method stub

	}

	@GET
	@Produces("application/json")
	@RequestMapping(value = "/TemplateValid", method = RequestMethod.GET, produces = "application/json")
	public Response validateTemplate(@RequestParam int request_info_id)
			throws IOException, SQLException, ParseException {
		int TemplateSuggesstion;
		RequestDetailsEntity entity = new RequestDetailsEntity();
		Gson gson = new Gson();

		JSONObject obj = new JSONObject();
		String jsonMessage = "";
		String jsonArray = "";

		RequestDetailsEntity ExportList = new RequestDetailsEntity();
		DeviceInterfaceEntity ExportList2 = new DeviceInterfaceEntity();
		InternetInfoEntity ExportList3 = new InternetInfoEntity();

		RequestDetailsExport.loadProperties();

		ExportList = requestDetailsExportRepo
				.findByrequestinfoid(request_info_id);
		ExportList2 = deviceInterfaceRepo.findByRequestInfoId(request_info_id);
		ExportList3 = internetInfoRepo.findByRequestInfoId(request_info_id);

		String Template_id = ExportList.getTemplateIdUsed();
		boolean flag = false;

		String Region = ExportList.getRegion();
		String vendor = ExportList.getVendor();
		String model = ExportList.getModel();
		String os = ExportList.getOs();
		String osversion = ExportList.getOs_version();

		// if ((!(Template_id.equals(""))) && (!(Template_id.equals("null")))) {
		// if((!(Template_id.equals("")))){
		if (isNullOrEmpty(Template_id)) {
			RequestDetailsExport.loadProperties();
			String path = RequestDetailsExport.TSA_PROPERTIES
					.getProperty("templateCreationPath") + "\\" + Template_id;
			File file = new File(path);
			String template = null;

			if (file.exists()) {
				flag = true;
				template = "Valid";
				obj.put(new String("Result"), "Success");
				obj.put(new String("Message"), "");
				TemplateSuggesstion = 1;
				obj.put(new String("TemplateSuggesstion"), TemplateSuggesstion);

			} else {
				flag = false;
				System.out.println("Invalid");
				obj.put(new String("Result"), "Failure");
				obj.put(new String("Message"),
						"C3P does not support this template");
				TemplateSuggesstion = 0;
				obj.put(new String("TemplateSuggesstion"), TemplateSuggesstion);
				String MessageReport = "Template Validation Failed";
				ExportList.setRequeststatus(MessageReport);
				requestDetailsExportRepo.save(ExportList);
			}

		}

		else {

			DcmConfigService dcmConfigService = new DcmConfigService();
			TemplateSuggestionDao templateSuggestionDao = new TemplateSuggestionDao();

			JSONArray array = new JSONArray();

			JSONObject jsonObj;
			try {

				JSONParser parser = new JSONParser();
				// JSONObject json = (JSONObject) parser.parse(configRequest);

				CreateConfigRequestDCM createConfigRequestDCM = new CreateConfigRequestDCM();

				createConfigRequestDCM.setModel(ExportList.getModel());
				createConfigRequestDCM.setOs(ExportList.getOs());
				createConfigRequestDCM.setOsVersion(ExportList.getOs_version());
				createConfigRequestDCM.setRegion(ExportList.getRegion());
				createConfigRequestDCM.setVendor(ExportList.getVendor());

				String templateId = dcmConfigService.getTemplateName(
						createConfigRequestDCM.getRegion(),
						createConfigRequestDCM.getVendor(),
						createConfigRequestDCM.getModel(),
						createConfigRequestDCM.getOs(),
						createConfigRequestDCM.getOsVersion());

				// List<String>
				// featureList=templateSuggestionDao.getListOfFeaturesForDeviceDetail(templateId);

				List<String> feat1 = validateFeatures(request_info_id);

				// String[] featuresList = new String[feat1.size()];
				System.out.println("Features present in Import:");
				for (int i = 0; i < feat1.size(); i++) {
					// featuresList[i] = feat1.get(i);
					System.out.println(feat1.get(i));
				}

				if (feat1.size() > 0) {
					for (int i = 0; i < feat1.size(); i++) {
						jsonObj = new JSONObject();
						jsonObj.put("value", feat1.get(i));

						array.put(jsonObj);
					}
					jsonArray = array.toString();
					obj.put(new String("Result"), "Success");
					obj.put(new String("Message"), "Success");
					obj.put(new String("featureList"), jsonArray);
					obj.put(new String("templateId"), templateId);
				} else {
					obj.put(new String("Result"), "Failure");
					obj.put(new String("Message"),
							"No features Present.Create the template first");
					obj.put(new String("featureList"), null);
				}

			}

			catch (Exception e) {
				System.out.println(e);
			}
			String jsonList = "";
			String TemplateList = "";
			try {

				JSONParser parser = new JSONParser();
				// JSONObject json = (JSONObject) parser.parse(jsonArray);
				// JSONArray arr = new JSONArray();
				// obj.put(new String("featureList"), jsonArray);

				List<String> feat1 = validateFeatures(request_info_id);

				// String[] featuresList = new String[feat1.size()];

				for (int i = 0; i < feat1.size(); i++) {
					// featuresList[i] = feat1.get(i);
					feat1.get(i);
				}
				// org.json.simple.JSONArray jsonArr =
				// (org.json.simple.JSONArray) json.get("featureList");

				// List<String> list = new ArrayList<String>();
				// for (int i = 0; i < jsonArr.size(); i++) {
				// JSONObject arrObj = (JSONObject) jsonArr.get(i);
				// list.add(arrObj.get("value").toString());
				// }
				CreateConfigRequestDCM createConfigRequestDCM = new CreateConfigRequestDCM();

				createConfigRequestDCM.setModel(ExportList.getModel());
				createConfigRequestDCM.setOs(ExportList.getOs());
				createConfigRequestDCM.setOsVersion(ExportList.getOs_version());
				createConfigRequestDCM.setRegion(ExportList.getRegion());
				createConfigRequestDCM.setVendor(ExportList.getVendor());

				String templateId = dcmConfigService.getTemplateName(
						createConfigRequestDCM.getRegion(),
						createConfigRequestDCM.getVendor(),
						createConfigRequestDCM.getModel(),
						createConfigRequestDCM.getOs(),
						createConfigRequestDCM.getOsVersion());

				String[] features = feat1.toArray(new String[feat1.size()]);
				// String templateId = json.get("templateId").toString();
				List<TemplateBasicConfigurationPojo> templateBasicConfigurationPojo = templateSuggestionDao
						.getDataGrid(features, templateId);
				List<String> templateList = new ArrayList<String>();
				for (TemplateBasicConfigurationPojo template : templateBasicConfigurationPojo) {
					templateList.add(template.getTemplateId());
				}
				System.out.println("List of Templates Present:" + templateList);
				jsonList = new Gson().toJson(templateBasicConfigurationPojo);
				if (!(jsonList.equals("[]"))) {

					obj.put(new String("TemplateDetailList"), jsonList);
					obj.put(new String("Result"), "Success");
					obj.put(new String("Message"), "Success");
					ExportList.setTemplateIdUsed(TemplateList);
					System.out.println("Matched Template Found for Selected features");
					if (TemplateList != null) {
						RequestDetailsExport.loadProperties();
						String path = RequestDetailsExport.TSA_PROPERTIES
								.getProperty("templateCreationPath")
								+ "\\"
								+ TemplateList;
						File file = new File(path);
						String template = null;

						if (file.exists()) {
							flag = true;
							template = "Valid";
							obj.put(new String("Result"), "Success");
							obj.put(new String("Message"), "");
							TemplateSuggesstion = 1;
							obj.put(new String("TemplateSuggesstion"),
									TemplateSuggesstion);
							System.out.println("Approved Template Found for Selected features");

						} else {
							flag = false;
							System.out.println("No Approved Template Found for Selected features");
							System.out.println("Invalid");
							obj.put(new String("Result"), "Failure");
							obj.put(new String("Message"),
									"C3P does not support this template");
							TemplateSuggesstion = 0;
							obj.put(new String("TemplateSuggesstion"),
									TemplateSuggesstion);
							String MessageReport = "Template Validation Failed";
							ExportList.setRequeststatus(MessageReport);
							requestDetailsExportRepo.save(ExportList);
						}

						requestDetailsExportRepo.save(ExportList);
						TemplateSuggesstion = 1;
						obj.put(new String("TemplateSuggesstion"),
								TemplateSuggesstion);

					}
				} else {
					obj.put(new String("Result"), "Failure");
					obj.put(new String("Message"),
							"No Data.Create the template first");
					obj.put(new String("TemplateDetailList"), null);
					TemplateSuggesstion = 0;
					obj.put(new String("TemplateSuggesstion"),
							TemplateSuggesstion);
					String MessageReport = "Template Validation Failed";
					ExportList.setRequeststatus(MessageReport);
					System.out.println("No Matched Template Found for Selected features");
				}

			} catch (Exception e) {
				System.out.println(e);
			}

		}
		requestDetailsExportRepo.save(ExportList);
		return Response
				.status(200)
				.header("Access-Control-Allow-Origin", "*")
				.header("Access-Control-Allow-Headers",
						"origin, content-type, accept, authorization")
				.header("Access-Control-Allow-Credentials", "true")
				.header("Access-Control-Allow-Methods",
						"GET, POST, PUT, DELETE, OPTIONS, HEAD")
				.header("Access-Control-Max-Age", "1209600").entity(obj)
				.build();

	}

	@GET
	@Produces("application/json")
	@RequestMapping(value = "/DataValid", method = RequestMethod.GET, produces = "application/json")
	public Response validateData(@RequestParam int request_info_id) {
		int Datavalidation;
		RequestDetailsEntity entity = new RequestDetailsEntity();
		Gson gson = new Gson();

		JSONObject obj = new JSONObject();
		String jsonMessage = "";
		String jsonArray = "";

		RequestDetailsEntity ExportList = new RequestDetailsEntity();
		DeviceInterfaceEntity ExportList2 = new DeviceInterfaceEntity();
		InternetInfoEntity ExportList3 = new InternetInfoEntity();
		try {
			RequestDetailsExport.loadProperties();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		ExportList = requestDetailsExportRepo
				.findByrequestinfoid(request_info_id);
		ExportList2 = deviceInterfaceRepo.findByRequestInfoId(ExportList
				.getRequestinfoid());
		ExportList3 = internetInfoRepo.findByRequestInfoId(ExportList
				.getRequestinfoid());

		InetAddressValidator ipValidator = new InetAddressValidator();

		List<String> Valid = new ArrayList<String>();
		List<String> feat1 = validateFeatures(request_info_id);
		String[] stringArray1 = new String[feat1.size()];
		System.out.println("Features for Validation");
		for (int i = 0; i < feat1.size(); i++) {
			stringArray1[i] = feat1.get(i);
			System.out.println(stringArray1[i]);
		}

		boolean flagwan, flaglan, flagloop, flagrout, flagenable, flagsnmp, flagbanner, flagvrf = false;
		List<String> feat = new ArrayList<String>();
		String result = "Invalid";
		int length = stringArray1.length;
		for (int i = 0; i < length; i++) {

			if (stringArray1[i].equals("WAN Interface"))

			{
				if ((isNullOrEmpty(ExportList2.getName()))
						& (isNullOrEmpty(ExportList2.getDescription()))
						& ((ipValidator.isValid(ExportList2.getIp())))
						& ((ipValidator.isValid(ExportList2.getMask())))
						& (isNullOrEmpty(ExportList2.getEncapsulation()))
						& (isNullOrEmpty(ExportList2.getBandwidth()))) {
					flagwan = true;
					String wan = "WAN Interface";
					System.out.println("WAN feature is  VALID");

					Valid.add("1");
					feat.add(wan);
				} else {

					System.out.println("WAN feature is INVALID");
					// result="Valid";

					Valid.add("0");
				}
			}
			if (stringArray1[i].equals("LAN Interface")) {
				if ((isNullOrEmpty(ExportList.getLanDescription()))
						& (isNullOrEmpty(ExportList.getLanInterface()))
						& (ipValidator.isValid(ExportList.getLanIp()))
						& (ipValidator.isValid(ExportList.getLanMaskAddress()))) {
					flaglan = true;
					String lan = "LAN Interface";
					System.out.println("LAN feature is VALID");
					// result="Valid";
					feat.add(lan);
					Valid.add("1");

				} else {
					System.out.println("LAN feature is INVALID");
					// result="InValid";
					Valid.add("0");
				}
			}
			if (stringArray1[i].equals("Loopback Interface")) {

				if ((isNullOrEmpty(ExportList.getLoopbackIPaddress()))
						& (ipValidator.isValid(ExportList
								.getLoopbackSubnetMask()))
						& (isNullOrEmpty(ExportList.getLoopBackType()))) {
					flagloop = true;
					String loop = "Loopback Interface";
					System.out.println("Loopback feature is VALID");
					// result="Valid";
					feat.add(loop);
					Valid.add("1");

				} else {
					System.out.println("Loopback feature is INVALID");
					// result="InValid";
					Valid.add("0");
				}
			}

			if (stringArray1[i].equals("Routing Protocol")) {

				if ((isNullOrEmpty(ExportList3.getRoutingProtocol()))
						& (isNullOrEmpty(ExportList3.getAsNumber()))
						& (isNullOrEmpty(ExportList3.getNeighbor1()))
						& (isNullOrEmpty(ExportList3.getNeighbor1RemoteAS()))
						& (isNullOrEmpty(ExportList3.getNeighbor2()))
						& (isNullOrEmpty(ExportList3.getNeighbor2RemoteAS()))
						& (ipValidator.isValid(ExportList3
								.getNetworkIpSubnetMask()))
						& (ipValidator.isValid(ExportList3.getNetworkIp()))) {
					flagrout = true;
					String rout = "Routing Protocol";
					System.out.println("BGP feature is VALID");
					// result="Valid";
					feat.add(rout);
					Valid.add("1");

				} else {

					System.out.println("Routing Protocol feature is INVALID");
					// result="InValid";
					Valid.add("0");
				}
			}

			if (stringArray1[i].equals("Enable Password")) {

				if ((isNullOrEmpty(ExportList.getEnable_password()))) {
					flagenable = true;
					String pass = "Enable Password";
					System.out.println("Enable password feature is VALID");
					feat.add(pass);
					// result="Valid";
					Valid.add("1");

				} else {
					System.out.println("Enable Password feature is INVALID");
					// result="InValid";
					Valid.add("0");
				}
			}

			if (stringArray1[i].equals("SNMP")) {
				if ((isNullOrEmpty(ExportList.getSnmpString()))
						& (!(ExportList.getSnmpHostAddress().isEmpty()))) {
					flagsnmp = true;
					String snmp = "SNMP";
					System.out.println("snmp feature is VALID");
					feat.add(snmp);
					// result="Valid";
					Valid.add("1");

				} else {
					System.out.println("SNMP feature is INVALID");
					// result="InValid";
					Valid.add("0");
				}
			}

			if (stringArray1[i].equals("Banner")) {
				if ((isNullOrEmpty(ExportList.getBanner()))) {
					flagbanner = true;
					String banner = "Banner";
					System.out.println("Banner feature is VALID");
					feat.add(banner);
					// result="Valid";
					Valid.add("1");

				} else {

					System.out.println("Banner feature is INVALID");
					// result="InValid";
					Valid.add("0");
				}
			}

			if (stringArray1[i].equals("VRF")) {
				if ((isNullOrEmpty(ExportList.getVrf_name()))) {

					flagvrf = true;
					String vrf = "VRF";
					System.out.println("vrf feature is VALID");
					feat.add(vrf);
					// result="Valid";
					Valid.add("1");

				} else {
					System.out.println("VRF feature is NOT VALID");
					// result="InValid";
					Valid.add("0");
				}
			}
			if (stringArray1[i].equals("Basic Configuration")) {
				System.out.println("");
			}

		}
		String[] stringArray = new String[feat.size()];
		// String result = "Invalid";
		for (int j = 0; j < Valid.size(); j++) {

			stringArray[j] = Valid.get(j);

			if (stringArray[j].equals("0")) {
				System.out.println("INVALID DATA REPORT");
				result = "InValid";
				break;
			} else {
				result = "Valid";
			}

			// System.out.println(stringArray[j]);
		}

		if (result == "Valid") {
			Datavalidation = 1;
			obj.put(new String("Result"), "Success");
		} else {
			Datavalidation = 0;
			obj.put(new String("Result"), "Failure");
			String MessageReport = "Data Validation Failed";
			ExportList.setRequeststatus(MessageReport);
		}
		requestDetailsExportRepo.save(ExportList);

		obj.put(new String("Datavalidation"), Datavalidation);

		return Response
				.status(200)
				.header("Access-Control-Allow-Origin", "*")
				.header("Access-Control-Allow-Headers",
						"origin, content-type, accept, authorization")
				.header("Access-Control-Allow-Credentials", "true")
				.header("Access-Control-Allow-Methods",
						"GET, POST, PUT, DELETE, OPTIONS, HEAD")
				.header("Access-Control-Max-Age", "1209600").entity(obj)
				.build();

	}

	@GET
	@Produces("application/json")
	@RequestMapping(value = "/TestAndTurn", method = RequestMethod.GET, produces = "application/json")
	public Response validateTest(@RequestParam int request_info_id)
			throws IOException, SQLException {
		int TestAndTurnUp;
		RequestDetailsEntity entity = new RequestDetailsEntity();
		Gson gson = new Gson();

		JSONObject obj = new JSONObject();
		String jsonMessage = "";
		String jsonArray = "";

		RequestDetailsEntity ExportList = new RequestDetailsEntity();

		RequestDetailsExport.loadProperties();

		ExportList = requestDetailsExportRepo
				.findByrequestinfoid(request_info_id);
		// =============

		String Region = ExportList.getRegion();
		String vendor = ExportList.getVendor();
		String model = ExportList.getModel();
		String os = ExportList.getOs();
		String osversion = ExportList.getOs_version();

		String templateId = dcmConfigService.getTemplateName(Region, vendor,
				model, os, osversion);

		List<String> featureList = templateSuggestionDao
				.getListOfFeaturesForDeviceDetail(templateId);
		if (featureList.size() > 0) {
			for (int i = 0; i < featureList.size(); i++) {
				jsonObj = new JSONObject();
				jsonObj.put("value", featureList.get(i));

				array.put(jsonObj);
			}
			jsonArray = array.toString();

			if (featureList.size() > 0) {
				for (int i = 0; i < featureList.size(); i++) {

					jsonObj = new JSONObject();
					jsonObj.put("value", featureList.get(i));
					if (featureList.get(i).equalsIgnoreCase(
							"Basic Configuration")) {
						jsonObj.put("selected", true);
						jsonObj.put("disabled", true);
					} else {
						jsonObj.put("selected", false);
						jsonObj.put("disabled", false);
					}

					array.put(jsonObj);
				}
				jsonArray = array.toString();

			}

			TemplateSuggestionDao templateSuggestionDao = new TemplateSuggestionDao();
			String jsonList = "";
			JSONArray array = new JSONArray();

			JSONObject jsonObj;

			try {
				JSONParser parser = new JSONParser();

				List<String> featureList1 = templateSuggestionDao
						.getListOfFeaturesForDeviceDetail(templateId);

				List<String> itemList = new ArrayList<String>();

				Object[] objNames = featureList1.toArray();

				String[] features = Arrays.copyOf(objNames, objNames.length,
						String[].class);

				System.out.println("ArrayList converted to String array");

				for (int i = 0; i < features.length; i++) {
					System.out.println(features[i]);

				}

				// =================
				TestAndTurnUp = 1;

				obj.put(new String("TestAndTurnUp"), TestAndTurnUp);
			} catch (Exception e) {
				System.out.println(e);
			}
		}
		return Response
				.status(200)
				.header("Access-Control-Allow-Origin", "*")
				.header("Access-Control-Allow-Headers",
						"origin, content-type, accept, authorization")
				.header("Access-Control-Allow-Credentials", "true")
				.header("Access-Control-Allow-Methods",
						"GET, POST, PUT, DELETE, OPTIONS, HEAD")
				.header("Access-Control-Max-Age", "1209600").entity(obj)
				.build();

	}

	@GET
	@Produces("application/json")
	@RequestMapping(value = "/Scheduler", method = RequestMethod.GET, produces = "application/json")
	public Response validateScheduler(@RequestParam int request_info_id)
			throws IOException, SQLException, java.text.ParseException,
			ParseException {
		int Scheduler;
		RequestDetailsEntity entity = new RequestDetailsEntity();
		Gson gson = new Gson();

		JSONObject obj = new JSONObject();
		String jsonMessage = "";
		String jsonArray = "";

		RequestDetailsEntity ExportList = new RequestDetailsEntity();

		RequestDetailsExport.loadProperties();

		ExportList = requestDetailsExportRepo
				.findByrequestinfoid(request_info_id);
		String Scheduled;
		String Result, Message;
		String RunNow;
		if (ExportList.getRequestType_Flag().equals("M"))

		{

			DateTimeFormatter dtf = DateTimeFormatter
					.ofPattern("yyyy-MM-dd HH:mm:ss");
			LocalDateTime now = LocalDateTime.now();
			System.out.println(dtf.format(now));

			RunNow = dtf.format(now);
			ExportList.setDate_of_processing(RunNow);
			requestDetailsExportRepo.save(ExportList);
			obj.put(new String("RunNow"), RunNow);
			obj.put(new String("SchedulerResult"), "Success");
			Result = "Valid";
			Message = "Valid Scheduled Time";
		}

		else {

			Scheduled = ExportList.getScheduledTime();

			String path1 = Scheduled.substring(0, 19);
			if (!path1
					.matches("^\\d{4}\\-(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])\\s([0-1]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)$"))

			{
				Result = "Invalid";
				Message = "Invalid Date Format";
				String MessageReport = "Scheduled Time Validation Failed";
				ExportList.setRequeststatus(MessageReport);
				System.out.println("Invalid Date Format");
				obj.put(new String("Message"), Message);
			}

			else {

				DateTimeFormatter dtf = DateTimeFormatter
						.ofPattern("yyyy-MM-dd HH:mm:ss");
				LocalDateTime now = LocalDateTime.now();
				System.out.println(dtf.format(now));
				RunNow = dtf.format(now);

				String Timeset = Scheduled.substring(0, 19);
				System.out.println(Timeset);

				int Value = compareDates(RunNow, Timeset);
				if (Value == 1) {
					System.out.println("Date is VALID after Current Date");
					Scheduled = ExportList.getScheduledTime().substring(0, 19);
					ExportList.setDate_of_processing(Scheduled);
					requestDetailsExportRepo.save(ExportList);
					obj.put(new String("Scheduled"), Scheduled);
					obj.put(new String("SchedulerResult"), "Success");
					Result = "Valid";
					Message = "Valid Scheduled Time";
					obj.put(new String("Message"), Message);
				} else {
					System.out.println("Date of processing is NOT VALID");
				
					obj.put(new String("SchedulerResult"), "Failure");
					Result = "InValid";
					Message = "Date should be greater than Current Time ";
					obj.put(new String("Message"), Message);

				}

			}
		}

		if (Result == "Valid") {
			Scheduler = 1;
			ExportList.setRequeststatus("Success");
		} else {
			Scheduler = 0;
			String MessageReport = "Scheduled Time Validation Failed";
			ExportList.setRequeststatus(MessageReport);

		}
		requestDetailsExportRepo.save(ExportList);
		obj.put(new String("Scheduler"), Scheduler);
		obj.put(new String("SchedulerResult"), Result);

		return Response
				.status(200)
				.header("Access-Control-Allow-Origin", "*")
				.header("Access-Control-Allow-Headers",
						"origin, content-type, accept, authorization")
				.header("Access-Control-Allow-Credentials", "true")
				.header("Access-Control-Allow-Methods",
						"GET, POST, PUT, DELETE, OPTIONS, HEAD")
				.header("Access-Control-Max-Age", "1209600").entity(obj)
				.build();

	}

	public List<String> validateFeatures(int request_info_id) {
		boolean flagwan, flaglan, flagloop, flagrout, flagenable, flagsnmp, flagbanner, flagvrf = false;
		List<String> feat = new ArrayList<String>();

		RequestDetailsEntity ExportList = new RequestDetailsEntity();
		DeviceInterfaceEntity ExportList2 = new DeviceInterfaceEntity();
		InternetInfoEntity ExportList3 = new InternetInfoEntity();

		ExportList = requestDetailsExportRepo
				.findByrequestinfoid(request_info_id);
		ExportList2 = deviceInterfaceRepo.findByRequestInfoId(request_info_id);
		ExportList3 = internetInfoRepo.findByRequestInfoId(request_info_id);

		if ((isNullOrEmpty(ExportList2.getName()))
				|| (isNullOrEmpty(ExportList2.getDescription()))
				|| (isNullOrEmpty(ExportList2.getIp()))
				|| (isNullOrEmpty(ExportList2.getMask()))
				|| (isNullOrEmpty(ExportList2.getEncapsulation()))
				|| (isNullOrEmpty(ExportList2.getBandwidth()))) {
			flagwan = true;
			String wan = "WAN Interface";
			System.out.println("WAN feature is PRESENT");
			feat.add(wan);

		} else {
			System.out.println("WAN feature is NOT PRESENT");
		}

		if ((isNullOrEmpty(ExportList.getLanDescription()))
				|| (isNullOrEmpty(ExportList.getLanInterface()))
				|| (isNullOrEmpty(ExportList.getLanIp()))
				|| (isNullOrEmpty(ExportList.getLanMaskAddress()))) {
			flaglan = true;
			String lan = "LAN Interface";
			System.out.println("LAN feature is PRESENT");
			feat.add(lan);
		} else {
			System.out.println("LAN feature is NOT PRESENT");
		}

		if ((isNullOrEmpty(ExportList.getLoopbackIPaddress()))
				|| (isNullOrEmpty(ExportList.getLoopbackSubnetMask()))
				|| (isNullOrEmpty(ExportList.getLoopBackType()))) {
			flagloop = true;
			String loop = "Loopback Interface";
			System.out.println("Loopback feature is PRESENT");
			feat.add(loop);

		} else {
			System.out.println("Loopback feature is NOT PRESENT");
		}
		if ((isNullOrEmpty(ExportList3.getRoutingProtocol()))
				// || (isNullOrEmpty(ExportList3.getAsNumber()))
				|| (isNullOrEmpty(ExportList3.getNeighbor1()))
				|| (isNullOrEmpty(ExportList3.getNeighbor1RemoteAS()))
				|| (isNullOrEmpty(ExportList3.getNeighbor2()))
				|| (isNullOrEmpty(ExportList3.getNeighbor2RemoteAS()))
				|| (isNullOrEmpty(ExportList3.getNetworkIpSubnetMask()))) {
			flagrout = true;
			String rout = "Routing Protocol";
			System.out.println("Routing Protocol feature is PRESENT");
			feat.add(rout);

		} else {
			System.out.println("BGP feature is NOT PRESENT");
		}
		if (isNullOrEmpty(ExportList.getEnable_password())) {
			flagenable = true;
			String pass = "Enable Password";
			System.out.println("Enable Password feature is PRESENT");
			feat.add(pass);

		} else {
			System.out.println("Enable password feature is NOT PRESENT");
		}

		if ((isNullOrEmpty(ExportList.getSnmpString()))
				|| (isNullOrEmpty(ExportList.getSnmpHostAddress()))) {
			flagsnmp = true;
			String snmp = "SNMP";
			System.out.println("SNMP feature is PRESENT");
			feat.add(snmp);

		} else {
			System.out.println("snmp feature is NOT PRESENT");
		}

		if (isNullOrEmpty(ExportList.getBanner())) {
			flagbanner = true;
			String banner = "Banner";
			System.out.println("Banner feature is PRESENT");
			feat.add(banner);

		} else {
			System.out.println("banner feature is NOT PRESENT");
		}
		if (isNullOrEmpty(ExportList.getVrf_name())) {
			flagvrf = true;
			String vrf = "VRF";
			System.out.println("VRF feature is PRESENT");
			feat.add(vrf);

		} else {
			System.out.println("vrf feature is NOT PRESENT");
		}
		String Basic = "Basic Configuration";
		feat.add(Basic);

		return feat;
	}

	public static int compareDates(String d1, String d2)
			throws java.text.ParseException, ParseException {
		// 1
		// Create 2 dates starts
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Date date1 = sdf.parse(d1);
		Date date2 = sdf.parse(d2);

		System.out.println("Date1" + sdf.format(date1));
		System.out.println("Date2" + sdf.format(date2));
		System.out.println();

		// Create 2 dates ends
		// 1
		int Valid = 0;
		// Date object is having 3 methods namely after,before and equals for
		// comparing
		// after() will return true if and only if date1 is after date 2
		if (date1.before(date2)) {
			System.out.println("Date1 is after Date2");
			Valid = 1;
		}
		// before() will return true if and only if date1 is before date2
		if (date1.after(date2)) {
			System.out.println("Invalid");
			Valid = 0;
		}

		// equals() returns true if both the dates are equal
		// if(date1.equals(date2)){
		// System.out.println("Date1 is equal Date2");
		// }

		System.out.println();
		return Valid;
	}

	public static boolean isNullOrEmpty(String str) {
		if (str != null && !str.isEmpty())
			return true;
		return false;
	}

}
